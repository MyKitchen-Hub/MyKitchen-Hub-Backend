# Release workflow - Creates production releases when version tags are pushed
# This workflow runs tests, builds production images, and creates releases
name: Release

# Trigger: Run when version tags (v*) are pushed to the repository
# Example: git tag v1.0.0 && git push origin v1.0.0
on:
  push:
    tags:
      - "v*" # Matches tags starting with 'v' (e.g., v1.0.0, v2.1.3)

jobs:
  build-and-release:
    # Use the latest Ubuntu runner for consistent build environment
    runs-on: ubuntu-latest

    permissions:
      contents: write
      packages: write

    steps:
      # Step 1: Check out the repository code at the tagged commit
      - uses: actions/checkout@v4

      # Step 2: Set up Java 21 with Eclipse Temurin distribution
      # Required for building the Spring Boot application
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"

      # Step 3: Cache Maven dependencies for faster builds
      # Reduces build time by reusing downloaded dependencies
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      # Step 4: Run full test suite before creating release
      # Ensures the tagged version passes all tests using H2 in-memory database
      - name: Run tests
        run: ./mvnw test -Dspring.profiles.active=test
        env:
          DB_URL: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
          DB_USERNAME: sa
          DB_PASSWORD:
          JWT_SECRET: testSecretKeyForTestingPurposesOnly12345678901234567890
          JWT_EXPIRATION: 3600000
          JWT_REFRESH_EXPIRATION: 604800000
          EMAIL: test@example.com
          EMAIL_PASSWORD: testpassword
          CLOUDINARY_CLOUD_NAME: test-cloud
          CLOUDINARY_API_KEY: test-api-key
          CLOUDINARY_API_SECRET: test-api-secret
          SERVER_PORT: 0
          SHOW_SQL: false

      # Step 5: Build the Spring Boot application with Maven
      # Creates the production JAR file for Docker image
      - name: Build application
        run: ./mvnw clean package -DskipTests

      # Step 6: Set up Docker Buildx for advanced Docker builds
      # Required for building and pushing Docker images
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Step 7: Authenticate with Docker Hub for image publishing
      # Uses secrets stored in GitHub repository settings
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Step 8: Generate Docker image metadata and release tags
      # Creates version-specific tags and updates 'latest' tag
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/mykitchen_hub
          tags: |
            type=ref,event=tag      # Tag with version number (e.g., v1.0.0)
            type=raw,value=latest   # Also tag as 'latest' for easy access

      # Step 9: Build and push production Docker image
      # Creates the official release image with version tags
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # Build context is the repository root
          file: ./Dockerfile # Dockerfile location
          push: true # Push to Docker Hub after building
          tags: ${{ steps.meta.outputs.tags }} # Use version and latest tags
          labels: ${{ steps.meta.outputs.labels }} # Add metadata labels
          cache-from: type=gha # Use GitHub Actions cache for layers
          cache-to: type=gha,mode=max # Save all layers to cache

      # Step 10: Create GitHub Release
      # Automatically creates a GitHub release with the Docker image information
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }} # Use the pushed tag name
          name: Release ${{ github.ref_name }} # Release title
          draft: false # Create as public release
          prerelease: false # Mark as stable release
          body: |
            ## Changes

            Docker image: `${{ secrets.DOCKER_USERNAME }}/mykitchen_hub:${{ github.ref_name }}`

            ## Installation

            ```bash
            docker pull ${{ secrets.DOCKER_USERNAME }}/mykitchen_hub:${{ github.ref_name }}
            ```

            ## Usage

            ```bash
            docker run -p 8080:8080 \
              -e DB_URL=jdbc:mysql://host.docker.internal:3306/mykitchen_hub \
              -e DB_USERNAME=your_username \
              -e DB_PASSWORD=your_password \
              -e JWT_SECRET=your_jwt_secret \
              -e EMAIL=your_email \
              -e EMAIL_PASSWORD=your_app_password \
              -e CLOUDINARY_CLOUD_NAME=your_cloud_name \
              -e CLOUDINARY_API_KEY=your_api_key \
              -e CLOUDINARY_API_SECRET=your_api_secret \
              ${{ secrets.DOCKER_USERNAME }}/mykitchen_hub:${{ github.ref_name }}
            ```

      # Step 11: Clean up Docker resources
      # Always runs to prevent resource leaks, even if previous steps fail
      - name: Clean up
        if: always() # Run even if previous steps fail
        run: docker system prune -f
        # Remove unused Docker resources to free up space
